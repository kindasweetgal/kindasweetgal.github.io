<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kinda</title>
  
  <subtitle>想要的都拥有，得不到的都释怀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-26T07:30:07.670Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hyliu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>吴恩达机器学习课时6学习笔记</title>
    <link href="http://yoursite.com/2020/06/26/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E6%97%B66%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/26/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E6%97%B66%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-26T07:23:36.882Z</published>
    <updated>2020-06-26T07:30:07.670Z</updated>
    
    <content type="html"><![CDATA[<p><strong>logistic回归解决分类问题</strong>，新的代价函数</p><p>— tags:    “机器学习” —</p><a id="more"></a><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200626151627744.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>线性回归和logistic回归不一样的是：</strong></p><ol><li>h（x）不一样。</li><li>logistic是分类问题，命名为回归是历史原因。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062615171481.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;logistic回归解决分类问题&lt;/strong&gt;，新的代价函数&lt;/p&gt;
&lt;p&gt;— tags:    “机器学习” —&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>吴恩达机器学习课时3学习笔记</title>
    <link href="http://yoursite.com/2020/06/26/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E6%97%B63%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/26/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E6%97%B63%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-26T07:23:36.880Z</published>
    <updated>2020-06-26T07:29:42.211Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关键词：线性回归，特征缩放，正规方程</strong></p><p>— tags:    “机器学习” —</p><a id="more"></a><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200626151250164.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关键词：线性回归，特征缩放，正规方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;— tags:    “机器学习” —&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode刷题9回文数（python）</title>
    <link href="http://yoursite.com/2020/06/26/leetcode%E5%88%B7%E9%A2%989%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/26/leetcode%E5%88%B7%E9%A2%989%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88python%EF%BC%89/</id>
    <published>2020-06-26T07:23:36.821Z</published>
    <updated>2020-06-26T07:29:25.158Z</updated>
    
    <content type="html"><![CDATA[<p>— tags:    “leetcode刷题记录” —</p><a id="more"></a><p><strong>题目描述</strong><br>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:</p><p>输入: 121<br>输出: true<br>示例 2:</p><p>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:</p><p>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>进阶:</p><p>你能不将整数转为字符串来解决这个问题吗？</p><p>来源：力扣（LeetCode）<br><strong>1.普通方法解决</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        y=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> x%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">            y=y*<span class="number">10</span>+x%<span class="number">10</span></span><br><span class="line">            x=x/<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;=y:</span><br><span class="line">                <span class="keyword">if</span> x==y <span class="keyword">or</span> x==y/<span class="number">10</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>108 ms    12.7 MB<br>速度超过97%的用户，第一次。。</p><p><strong>2.利用字符串解决：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        x=str(x)</span><br><span class="line">        s=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">            s+=x[len(x)-i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> s==x:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><pre><code>140 ms    12.6 MB</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— tags:    “leetcode刷题记录” —&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 7整数反转（python）</title>
    <link href="http://yoursite.com/2020/06/26/leetcode%207%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%EF%BC%88python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/26/leetcode%207%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%EF%BC%88python%EF%BC%89/</id>
    <published>2020-06-26T07:23:36.819Z</published>
    <updated>2020-06-26T07:28:49.252Z</updated>
    
    <content type="html"><![CDATA[<p>— tags:    “leetcode刷题记录” —</p><a id="more"></a><p><strong>题目描述</strong><br>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:<br>输入: 123<br>输出: 321</p><p> 示例 2:<br>输入: -123<br>输出: -321</p><p>示例 3:<br>输入: 120<br>输出: 21<br>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2的31次方,  2的31次方 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p>来源：力扣（LeetCode）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        <span class="comment"># python对整数除法采用“向下取整”机制，所以正数和负数要区别运算</span></span><br><span class="line">        <span class="comment">#这里全部转化为正数</span></span><br><span class="line">        <span class="keyword">if</span> x&lt;<span class="number">0</span>: </span><br><span class="line">            x=-x</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">        y=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x !=<span class="number">0</span>:</span><br><span class="line">            y=y*<span class="number">10</span>+x%<span class="number">10</span></span><br><span class="line">            x=x/<span class="number">10</span></span><br><span class="line">        y = y <span class="keyword">if</span> flag <span class="keyword">else</span> -y</span><br><span class="line">        <span class="keyword">if</span> y&gt;pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span> <span class="keyword">or</span> y&lt;pow(<span class="number">-2</span>,<span class="number">31</span>): <span class="keyword">return</span> <span class="number">0</span>    <span class="comment">#判断是否溢出</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>执行用时：36 ms<br>内存消耗：12.6 MB</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— tags:    “leetcode刷题记录” —&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 两数相加 python实现</title>
    <link href="http://yoursite.com/2020/06/24/leetcode%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20python%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/06/24/leetcode%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20python%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-24T15:00:57.112Z</published>
    <updated>2020-06-26T07:29:01.049Z</updated>
    
    <content type="html"><![CDATA[<p>— tags:    “leetcode刷题记录” —</p><a id="more"></a><p><strong>题目描述：</strong><br>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><!-- more --><p><strong>示例：</strong></p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>来源：力扣（LeetCode）</p><p>官方实现java：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a></p><p>执行用时 :92 ms<br>内存消耗 :12.9 MB</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        f=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#python原来用is判断啊</span></span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        l3=ListNode(<span class="number">0</span>) <span class="comment">#每个节点都要new一个</span></span><br><span class="line">        res =l3</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:   <span class="comment">#python 原来是or啊</span></span><br><span class="line">            summ=<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l1 :</span><br><span class="line">                summ+=l1.val</span><br><span class="line">                l1=l1.next</span><br><span class="line">            <span class="keyword">if</span> l2 :</span><br><span class="line">                summ+=l2.val</span><br><span class="line">                l2=l2.next</span><br><span class="line">            <span class="keyword">if</span> (summ+f)&gt;<span class="number">9</span> :</span><br><span class="line">                res.next=ListNode(summ+f<span class="number">-10</span>)</span><br><span class="line">                f=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                res.next=ListNode(summ+f)</span><br><span class="line">                f=<span class="number">0</span></span><br><span class="line">            res=res.next</span><br><span class="line">        <span class="keyword">if</span> f!=<span class="number">0</span>:</span><br><span class="line">            res.next=ListNode(f)</span><br><span class="line">        <span class="keyword">return</span> l3.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— tags:    “leetcode刷题记录” —&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>吴恩达机器学习编程练习1：线性回归（python）</title>
    <link href="http://yoursite.com/2020/06/24/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A01%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%88python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/24/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A01%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%88python%EF%BC%89/</id>
    <published>2020-06-24T14:59:55.906Z</published>
    <updated>2020-06-26T07:30:15.802Z</updated>
    
    <content type="html"><![CDATA[<p>— tags:    “机器学习” —</p><a id="more"></a><h2 id="一：返回一个5阶单位矩阵"><a href="#一：返回一个5阶单位矩阵" class="headerlink" title="一：返回一个5阶单位矩阵"></a>一：返回一个5阶单位矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">warmupExercise</span><span class="params">()</span>:</span></span><br><span class="line">E5=np.eye(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'这是一个五阶单位矩阵'</span>)</span><br><span class="line">print(E5)</span><br><span class="line"></span><br><span class="line">warmupExercise()</span><br></pre></td></tr></table></figure><h2 id="二：线性回归"><a href="#二：线性回归" class="headerlink" title="二：线性回归"></a>二：线性回归</h2><p><strong>1.含有一个变量，大意是：假如你是一个饭店老板，要在其他城市拓展业务，现有数据在ex1data.txt第一列是人口，第二列是收益</strong><br>导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><p>将数据读取，进行展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'ex1data1.txt'</span>,names=[<span class="string">'Population'</span>,<span class="string">'Profit'</span>])</span><br><span class="line">data.describe()</span><br><span class="line">data.plot(x=<span class="string">'Population'</span>,y=<span class="string">'Profit'</span>,kind=<span class="string">'scatter'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624145847565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.describe()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062414593137.png" alt="在这里插入图片描述"><br>定义损失函数：<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624152110203.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062415212672.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#代价函数</span></span><br><span class="line">    <span class="comment"># * 在matrix类型中是矩阵的叉乘，multiply是对应元素相乘</span></span><br><span class="line">    <span class="comment"># * 在ndarray类型中，dot或 @ 是叉乘，* 是对应元素相乘</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span><span class="params">(X,y,theta)</span>:</span></span><br><span class="line">    inner = np.power(((X*theta.T) - y ),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sum(inner)/(<span class="number">2</span>*len(X))</span><br></pre></td></tr></table></figure><p>能够直接矩阵相乘，增加一列1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加x0</span></span><br><span class="line">data.insert(<span class="number">0</span>,<span class="string">'Ones'</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将数据分割出来，0-1列是变量x，2列是y</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cols = data.shape[<span class="number">1</span>]</span><br><span class="line">print(cols)</span><br><span class="line">X = data.iloc[:,<span class="number">0</span>:cols<span class="number">-1</span>]</span><br><span class="line">y = data.iloc[:,cols<span class="number">-1</span>:cols]</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.head()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062415255461.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y.head()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624152624552.png" alt="在这里插入图片描述"><br>转化成matrix类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = np.matrix(X.values)</span><br><span class="line">y = np.matrix(y.values)</span><br><span class="line">theta = np.matrix([<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.shape,y.shape,theta.shape</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062415365094.png" alt="在这里插入图片描述"><br>计算代价函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computeCost(X,y,theta)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062415373494.png" alt="在这里插入图片描述"><br>设置梯度下降<br>公式：<img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624155342686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(X, y, theta, alpha, epoch)</span>:</span></span><br><span class="line">    <span class="string">"""reuturn theta, cost"""</span></span><br><span class="line">    </span><br><span class="line">    temp = np.matrix(np.zeros(theta.shape))  <span class="comment"># 初始化一个 θ 临时矩阵(1, 2)</span></span><br><span class="line">    parameters = int(theta.flatten().shape[<span class="number">1</span>])  <span class="comment"># 参数 θ的数量</span></span><br><span class="line">    cost = np.zeros(epoch)  <span class="comment"># 初始化一个ndarray，包含每次epoch的cost</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]  <span class="comment"># 样本数量m</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">        <span class="comment"># 利用向量化一步求解</span></span><br><span class="line">        temp =theta - (alpha / m) * (X * theta.T - y).T * X</span><br><span class="line"><span class="comment"># 以下是不用Vectorization求解梯度下降</span></span><br><span class="line"><span class="comment">#         error = (X * theta.T) - y  # (97, 1)</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         for j in range(parameters):</span></span><br><span class="line"><span class="comment">#             term = np.multiply(error, X[:,j])  # (97, 1)</span></span><br><span class="line"><span class="comment">#             temp[0,j] = theta[0,j] - ((alpha / m) * np.sum(term))  # (1,1)        </span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        theta = temp</span><br><span class="line">        cost[i] = computeCost(X, y, theta)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> theta, cost</span><br></pre></td></tr></table></figure><p>设置学习率和迭代次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line">epoch = <span class="number">1000</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_theta,cost = gradientDescent(X,y,theta,alpha,epoch)</span><br></pre></td></tr></table></figure><p>计算最后的损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computeCost(X ,y ,final_theta)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624155632330.png" alt="在这里插入图片描述"><br>绘制线性模型以及数据，直观地看出它的拟合。</p><p>np.linspace()在指定的间隔内返回均匀间隔的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(data.Population.min(),data.Population.max(),<span class="number">100</span>)</span><br><span class="line">f = final_theta[<span class="number">0</span>,<span class="number">0</span>] + (final_theta[<span class="number">0</span>,<span class="number">1</span>]*x) <span class="comment">#预测值</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">ax.plot(x, f,<span class="string">'r'</span>, label = <span class="string">'Prediction'</span>)</span><br><span class="line">ax.scatter(data[<span class="string">'Population'</span>],data.Profit,label=<span class="string">'Traing Data'</span>)</span><br><span class="line">ax.legend(loc=<span class="number">2</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'Population'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Profit'</span>)</span><br><span class="line">ax.set_title(<span class="string">'Predicted Profit vs. Population Size'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624155808626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将cost绘制出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">ax.plot(np.arange(epoch),cost,<span class="string">'r'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'Iterations'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Cost'</span>)</span><br><span class="line">ax.set_title(<span class="string">'Error vs. Training Epoch'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624162229456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.多个变量：ex2data.txt第一列房子大小，第二列房子卧室数量，第三列房子价格。预测房价。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">'ex1data2.txt'</span></span><br><span class="line">data2 = pd.read_csv(path, names=[<span class="string">'Size'</span>, <span class="string">'Bedrooms'</span>,<span class="string">'Price'</span>])</span><br><span class="line">data2.head()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624162755689.png" alt="在这里插入图片描述"><br>预处理步骤 - 特征归一化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data2 = (data2 - data2.mean())/data2.std()</span><br><span class="line">data2.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add ones column</span></span><br><span class="line">data2.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set X (training data) and y (target variable)</span></span><br><span class="line">cols = data2.shape[<span class="number">1</span>]</span><br><span class="line">X2 = data2.iloc[:,<span class="number">0</span>:cols<span class="number">-1</span>]</span><br><span class="line">y2 = data2.iloc[:,cols<span class="number">-1</span>:cols]</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert to matrices and initialize theta</span></span><br><span class="line">X2 = np.matrix(X2.values)</span><br><span class="line">y2 = np.matrix(y2.values)</span><br><span class="line">theta2 = np.matrix(np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># perform linear regression on the data set</span></span><br><span class="line">g2, cost2 = gradientDescent(X2, y2, theta2, alpha, epoch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the cost (error) of the model</span></span><br><span class="line">computeCost(X2, y2, g2), g2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062422411519.png" alt="在这里插入图片描述"><br>绘制代价函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax.plot(np.arange(epoch),cost2,<span class="string">'r'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'Iterations'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Cost'</span>)</span><br><span class="line">ax.set_title(<span class="string">'Error vs. Training Epoch'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020062422401064.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>利用sklearn自带的线性回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line">model = linear_model.LinearRegression()</span><br><span class="line">model.fit(X,y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x =np.array(X[:,<span class="number">1</span>].A1)</span><br><span class="line">f = model.predict(X).flatten()</span><br><span class="line"></span><br><span class="line">fig,ax = plt.subplots(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">ax.plot(x, f , <span class="string">'r'</span>,label=<span class="string">'Prediction'</span>)</span><br><span class="line">ax.scatter(data.Population,data.Profit,label=<span class="string">'Traning Data'</span>)</span><br><span class="line">ax.legend(loc=<span class="number">2</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'Population'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Profit'</span>)</span><br><span class="line">ax.set_title(<span class="string">'Predicted Profit vs. Population Size'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624224230128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>直接求解的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正规方程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalEpn</span><span class="params">(X,y)</span>:</span></span><br><span class="line">    theta = np.linalg.inv(X.T@X)@X.T@y</span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final_theta2 = normalEpn(X,y)</span><br><span class="line">final_theta</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200624224302997.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— tags:    “机器学习” —&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode：两数之和 python实现</title>
    <link href="http://yoursite.com/2020/06/15/leetcode%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20python%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/06/15/leetcode%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20python%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-15T01:43:55.819Z</published>
    <updated>2020-06-26T07:29:13.220Z</updated>
    
    <content type="html"><![CDATA[<p>— tags:    “leetcode刷题记录” —</p><a id="more"></a><p>题目描述：<br><strong>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>来源：力扣（LeetCode）</strong></p><p>参照官方文档实现, 刚学python，详细记录不会的点</p><p><strong>方法一：暴力解题，双重循环</strong><br>脑子里只有这一种方法。。</p><p><strong>收获：1.  list的长度函数len()<br>           2.  range()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]==target:</span><br><span class="line">                    <span class="keyword">return</span> i,j</span><br></pre></td></tr></table></figure><p>执行用时：3184 ms    内存消耗：13.5 MB<br>时间复杂度O（n²）   空间复杂度O（1）</p><p>方法二：两遍哈希表<br>原来python的字典就是c++的map啊。。</p><p><strong>收获：判断字典中含不含有某个键值用 if key in dict，has_key()在python3不能使用了。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dict1=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            dict1[nums[i]]=i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            c=target-nums[i]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dict1:</span><br><span class="line">                <span class="keyword">if</span> dict1[c]!=i:</span><br><span class="line">                    <span class="keyword">return</span> i,dict1[c]</span><br></pre></td></tr></table></figure><p>执行用时：40 ms        内存消耗：14.1 MB<br>时间复杂度：O(n)     空间复杂度：O(n)</p><p>方法三：一遍哈希表<br><strong>真巧妙啊！！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        dict2=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            c=target-nums[i]</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dict2:</span><br><span class="line">                <span class="keyword">return</span> dict2[c],i</span><br><span class="line">            dict2[nums[i]]=i</span><br></pre></td></tr></table></figure><p>执行用时：32 ms        内存消耗：14 MB<br>时间复杂度：O(n)     空间复杂度：O(n)</p><p>title: leetcode：两数之和 python实现<br>date: 2020-06-15 9:44:13<br>tags:</p><ul><li>leetcode</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— tags:    “leetcode刷题记录” —&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>yolov3训练自己的数据集（darknet）+visdrone数据集</title>
    <link href="http://yoursite.com/2020/06/15/yolov3%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%88darknet%EF%BC%89+visdrone%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/15/yolov3%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%88darknet%EF%BC%89+visdrone%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-06-15T01:43:55.817Z</published>
    <updated>2020-06-15T01:54:00.784Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全部完成分为下面几个步骤：</strong><br>1.制作自己的数据集-将visdrone转化为yolo所需的格式 （下面先完成这部分）<br>2.配置yolov3<br>3.训练验证及计算map</p><a id="more"></a><p><strong>下篇链接：[<a href="https://blog.csdn.net/daisy_d_/article/details/105771633]" target="_blank" rel="noopener">https://blog.csdn.net/daisy_d_/article/details/105771633]</a></strong></p><p>踩了很多坑，分享一下自己训练的经历~<br>我使用的<strong>visdrone数据集</strong>包含很多小目标，选择的<strong>darknet框架下的yolov3</strong>。也尝试了pytorch版本的不过刚开始效果不好，等的很着急后来放弃了，到后来才知道这个数据集现需要很长时间训练，我用的云服务器1080ti显卡，大概需要60个小时<del>~</del></p><p>数据集下载链接：<a href="https://www.jianshu.com/p/62e827306fca" target="_blank" rel="noopener">https://www.jianshu.com/p/62e827306fca</a><br>。使用的VisDrone2018-DET dataset 的trainset（1.44GB）和valset（0.07GB）</p><p>darknet的yolo下载链接：<a href="https://github.com/pjreddie/darknet.git" target="_blank" rel="noopener">https://github.com/pjreddie/darknet.git</a></p><h2 id="制作数据集"><a href="#制作数据集" class="headerlink" title="制作数据集"></a>制作数据集</h2><p>最终形成的数据集的格式：<br>    images —— 存放.jpg图像<br>    Annotations —— 存放图像对应的xml文件<br>    ImagesSets/Main —— 存放用于train/test图像的名字列表txt<br>    labels——标签<br>    test.txt<br>    train.txt<br>    val.txt</p><p>我参考的链接：<a href="https://blog.csdn.net/qq_37775990/article/details/90145081" target="_blank" rel="noopener">https://blog.csdn.net/qq_37775990/article/details/90145081</a><br>下面需要的代码我放在了百度网盘：<br><a href="https://pan.baidu.com/s/17Nywnkb1d4SjMqxUdMQqJA" target="_blank" rel="noopener">https://pan.baidu.com/s/17Nywnkb1d4SjMqxUdMQqJA</a> 提取码：kPjI </p><p><strong>1.图片标注重命名</strong>（可做可不做，只是改变了名字）<br>使用 <strong>rename.py</strong> 对<strong>图像</strong>文件进行重命名，对<strong>标注</strong>文件进行重命名（两个步骤都要做，注意修改程序中的路径）会得到下面的效果，简单示例。<img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200425132600524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200425132600458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXN5X2Rf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2.visdrone标注转换为VOC格式</strong></p><p>运行<strong>main.py</strong> 进行转换，同样注意修改程序中的路径。注意需要新建对应文件夹Annotations_否则会报错。<br>visdrone的标注方式与yolo标注不一样。这个步骤是将annotations中的txt将标注转换为VOC格式的xml.</p><p><strong>3.生成用于train、val的图像名字列表txt（生成于ImagesSets/Main下）</strong></p><p>运行 <strong>trainnamelist.py</strong> 形成了列表txt。此处生成了四个文件（train.txt test.txt val.txt trainval.txt）可以根据自己需要修改生成相应的文件。<br>这个步骤是将数据库中的图像进行随机抽取，分成4部分，一部分作为train(训练)，一部分作为validation(验证)，一部分test(测试)，（trainval暂时没明白。。）最后将这几部分图像的名字写入txt。</p><p><strong>4.生成label文件夹和txt文件</strong></p><p>运行<strong>label.py</strong>就会在目录下生成一个labels文件夹，三个txt文件。<br>lable.py下有类别，我这次只训练了10个类别，所以注释掉了第0类和第11类（’ignored regions’和’others‘）加上了if判断语句，其他类别的id数值也需要-1。这样就少了第0类和第11类，整体只有10类了。 具体位置代码里注释了一下。<br>这个步骤是生成labels文件夹，里面就是适合yolov3的标注文件了，和图像名称一一对应，内容意义是:<br>(class,   x_center ,   y_center ,   w  , h)<br>目标类别      标注框中心x轴相对坐标   标注框长宽相对长度<br>因为坐标和长宽都是相对整幅图像长宽的比例，所以数值应该是0-1。</p><p>第一次写博客，有什么错误请多指教<br>我第一次转化数据集的时候花了一天多的时间才搞明白，如果你也是第一次不要着急。加油丫<del>~</del></p><p>title:yolov3训练自己的数据集（darkent）+visdrone<br>date: 2020-04-06 10:44:13<br>tags:</p><ul><li>yolov3训练</li><li>visdrone数据集</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;全部完成分为下面几个步骤：&lt;/strong&gt;&lt;br&gt;1.制作自己的数据集-将visdrone转化为yolo所需的格式 （下面先完成这部分）&lt;br&gt;2.配置yolov3&lt;br&gt;3.训练验证及计算map&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>吴恩达机器学习 课时2 学习笔记</title>
    <link href="http://yoursite.com/2020/06/06/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E8%AF%BE%E6%97%B62%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/06/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E8%AF%BE%E6%97%B62%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-06T14:34:31.087Z</published>
    <updated>2020-06-15T01:57:14.286Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录</p><a id="more"></a><h3 id="课时2-1-模型描述"><a href="#课时2-1-模型描述" class="headerlink" title="课时2-1 模型描述"></a>课时2-1 模型描述</h3><p>m=训练样本数量</p><p>x=输入变量/特征</p><p>y=输出变量/目标变量</p><p>（x，y）一个训练样本</p><p>（x<sup>(i)</sup>,y<sup>(i)</sup>） 第i个样本·</p><p>h假设函数（hypothesis ）</p><h3 id="课时2-2-代价函数"><a href="#课时2-2-代价函数" class="headerlink" title="课时2-2 代价函数"></a>课时2-2 代价函数</h3><p>h<sub>θ</sub>（x)=θ<sub>0</sub>+θ<sub>1</sub>*x</p><p>尽量选择参数合理准确地预测y</p><p>代价函数：（平方误差代价函数）<br>$$<br>minimize \frac{1}{2m}\sum_{i=1}^m(h_θ(x^{(i)})-y^{(i)})^2<br>$$<br>（加二分之一为了好求导）</p><h3 id="课时2-3-代价函数（一）"><a href="#课时2-3-代价函数（一）" class="headerlink" title="课时2-3 代价函数（一）"></a>课时2-3 代价函数（一）</h3><p>![](F:\blog\blog\source_posts\pictures\cost function.png)</p><h3 id="课时2-4-代价函数（二）"><a href="#课时2-4-代价函数（二）" class="headerlink" title="课时2-4 代价函数（二）"></a>课时2-4 代价函数（二）</h3><p>代价函数计算，等高线绘制</p><h3 id="课时2-5-梯度下降"><a href="#课时2-5-梯度下降" class="headerlink" title="课时2-5 梯度下降"></a>课时2-5 梯度下降</h3><p><img src= "/img/loading.gif" data-src="F:%5Cblog%5Cblog%5Csource_posts%5Cpictures%5Cgradient_descent.jpg" alt=""></p><h3 id="课时2-6-梯度下降知识点总结"><a href="#课时2-6-梯度下降知识点总结" class="headerlink" title="课时2-6 梯度下降知识点总结"></a>课时2-6 梯度下降知识点总结</h3><p>学习率：太小下降太慢，太大来回跳跃。</p><p>局部极小值：梯度下降会自动采用更小的步幅</p><h3 id="课时2-7-线性回归的梯度下降"><a href="#课时2-7-线性回归的梯度下降" class="headerlink" title="课时2-7 线性回归的梯度下降"></a>课时2-7 线性回归的梯度下降</h3><p><img src= "/img/loading.gif" data-src="F:%5Cblog%5Cblog%5Csource_posts%5Cpictures%5C2-7.png" alt=""></p><p>线性回归模型呈碗状</p><p>Batch梯度下降法：全览整个数据集</p><p>title:吴恩达机器学习 课时 1 学习笔记<br>date: 2020-06-06 10:44:13<br>tags:</p><ul><li>机器学习</li><li>学习笔记</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>吴恩达机器学习 课时 1 学习笔记</title>
    <link href="http://yoursite.com/2020/06/06/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E8%AF%BE%E6%97%B6%201%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/06/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E8%AF%BE%E6%97%B6%201%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-06T02:37:49.368Z</published>
    <updated>2020-06-15T01:56:41.863Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录</p><a id="more"></a><h2 id="课时1-1-欢迎参加《机器学习》课程"><a href="#课时1-1-欢迎参加《机器学习》课程" class="headerlink" title="课时1-1 欢迎参加《机器学习》课程"></a>课时1-1 欢迎参加《机器学习》课程</h2><h5 id="机器学习："><a href="#机器学习：" class="headerlink" title="机器学习："></a>机器学习：</h5><p>​    1.人工智能发展出来的一个领域</p><p>​    2.计算机开发的一项新功能</p><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><p>​    1.数据挖掘</p><p>​        自动化、互联网上的大量数据</p><p>​    2.不能用手来编程的应用</p><p>​        手写识别，自然语言处理和计算机视觉</p><p>​    3.私人定制程序</p><p>​        产品推荐</p><p>​    4.理解人类学习（大脑、真实的AI）</p><h2 id="课时1-2-什么是机器学习"><a href="#课时1-2-什么是机器学习" class="headerlink" title="课时1-2 什么是机器学习"></a>课时1-2 什么是机器学习</h2><h5 id="机器学习的定义："><a href="#机器学习的定义：" class="headerlink" title="机器学习的定义："></a>机器学习的定义：</h5><p>Arthur Samuel：Field of study that gives computers the ability to learn without being explicitly programmed.</p><p>在没有明确设置的情况下，使计算机具有学习能力的研究领域</p><p>Tom Mitchell ：Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measure by P, improves with experience E.</p><p>计算机程序从经验E中进行学习，解决某一任务T，进行某一性能度量P，通过P测定在T上的表现因经验E提高。</p><h5 id="机器学习算法："><a href="#机器学习算法：" class="headerlink" title="机器学习算法："></a>机器学习算法：</h5><pre><code>监督学习</code></pre><p>​    无监督学习</p><p>其他： 强化学习，推荐系统</p><h2 id="课时1-3-监督学习"><a href="#课时1-3-监督学习" class="headerlink" title="课时1-3 监督学习"></a>课时1-3 监督学习</h2><p>例子：房价预测，肿瘤良性or恶性预测</p><p><strong>监督学习</strong>：给一个数据集其中包括了<strong>正确答案</strong>，</p><p><strong>1. 回归问题</strong>：预测更多连续的有价值的输出</p><p><strong>2. 分类</strong>：预测一个（组）离散值输出</p><h2 id="课时1-4-无监督学习"><a href="#课时1-4-无监督学习" class="headerlink" title="课时1-4 无监督学习"></a>课时1-4 无监督学习</h2><p>Unsupervised algorithm</p><p>聚类算法：组织计算机集群，社交网络分析，市场细分，天文数据分析</p><p>title:吴恩达机器学习 课时 1 学习笔记<br>date: 2020-06-06 10:44:13<br>tags:</p><ul><li>机器学习</li><li>学习笔记</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
